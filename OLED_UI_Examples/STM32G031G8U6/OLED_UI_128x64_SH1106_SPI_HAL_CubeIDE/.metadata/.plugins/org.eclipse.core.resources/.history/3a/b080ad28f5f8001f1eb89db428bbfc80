#include "LIS2DH12.h"

#include "main.h"
#include "string.h"

uint8_t I2C_busy = 0;

extern I2C_HandleTypeDef hi2c2;


#define SDA_PIN GPIO_PIN_12	//GPIOA
#define SCL_PIN GPIO_PIN_11	//GPIOA
#define RES_PIN	GPIO_PIN_6	//GPIOC


// 软件实现I2C
void I2C_Delay()
{
    unsigned char i = 0;
    for (i = 0; i < 100; i++)
        ;
}

void I2C_Start()
{
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 1);
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 0);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
    I2C_Delay();
}

void I2C_Stop()
{
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 0);
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 1);
    I2C_Delay();
}

void I2C_SendData(unsigned char dat)
{
    unsigned char i = 0;
    for (i = 0; i < 8; i++)
    {
        HAL_GPIO_WritePin(GPIOA, SDA_PIN, dat & 0x80);
        HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
        I2C_Delay();
        HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
        I2C_Delay();
        dat <<= 1;
    }
}

unsigned char I2C_RecvData()
{
    unsigned char i = 0;
    unsigned char dat = 0;
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 1);
    for (i = 0; i < 8; i++)
    {
        dat <<= 1;
        HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
        I2C_Delay();
        if (HAL_GPIO_ReadPin(GPIOA, SDA_PIN))
        {
            dat |= 0x01;
        }
        HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
        I2C_Delay();
    }
    return dat;
}

void I2C_RecvACK()
{
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 1);
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
    I2C_Delay();
}

void I2C_SendACK()
{
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 0);
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
    I2C_Delay();
}

void I2C_SendNAK()
{
    HAL_GPIO_WritePin(GPIOA, SDA_PIN, 1);
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 1);
    I2C_Delay();
    HAL_GPIO_WritePin(GPIOA, SCL_PIN, 0);
    I2C_Delay();
}

/**
 * @brief 向LIS2DH12写入数据
 *
 * @param reg 内部寄存器地址
 * @param dat 数据。8bit
 */
void I2C_Write_to_LIS2DH12(unsigned char reg, unsigned char dat)
{
	HAL_I2C_Mem_Write(&hi2c2, LIS2DH12_ADDR_WRITE, reg, 1, &dat, 1, 100);
	/*
    I2C_Start();
    I2C_Delay();
    I2C_SendData(LIS2DH12_ADDR_WRITE);
    I2C_RecvACK();
    I2C_SendData(reg);
    I2C_RecvACK();
    I2C_SendData(dat);
    I2C_RecvACK();
    I2C_Delay();
    I2C_Stop();
    */
}

/**
 * @brief 从LIS2DH12读取数据
 *
 * @param reg 地址
 * @return unsigned char
 */
unsigned char I2C_Read_from_LIS2DH12(unsigned char reg)
{
	unsigned char dat;
	HAL_I2C_Mem_Read(&hi2c2, LIS2DH12_ADDR_READ, reg, 1, &dat, 1, 100);
	/*
    I2C_Start();
    I2C_Delay();
    I2C_SendData(LIS2DH12_ADDR_WRITE);
    I2C_RecvACK();
    I2C_SendData(reg);
    I2C_RecvACK();
    I2C_Start();
    I2C_SendData(LIS2DH12_ADDR_READ);
    I2C_RecvACK();
    dat = I2C_RecvData();
    I2C_SendNAK();
    I2C_Delay();
    I2C_Stop();*/
    return dat;
}

// LIS2DH12初始化
int LIS2DH12_init()
{
    unsigned char who_am_i = 0;
    // 芯片复位
    HAL_GPIO_WritePin(GPIOC, RES_PIN, 1);
    HAL_GPIO_WritePin(GPIOC, RES_PIN, 0);
    HAL_Delay(100);		//等待芯片启动
    // 读取WHO_AM_I寄存器，检查LIS2DH12是否存在
    who_am_i = I2C_Read_from_LIS2DH12(LIS2DH12_WHO_AM_I);
    // 判断是否成功读取WHO_AM_I寄存器
    if (who_am_i == 0x33)
    {
        //UartSendStr("LIS2DH12 init success!\r\n");
    }
    else
    {
        //UartSendStr("LIS2DH12 init failed!\r\n");
        // UartSendHex(who_am_i);
        // UartSendStr("\r\n");
        return -1;
    }
    //I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG1, 0x37); // 关闭sensor，设置进入掉电模式 ODR 25HZ
    //  从掉电模式中恢复时，建议先读取寄存器 REFERENCE (26h) 以彻底复位滤波块。
    //I2C_Read_from_LIS2DH12(LIS2DH12_REFERENCE);
    //I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG5, 0x80); // 清空内存
    I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG4, 0x88); // 使能快，数据更新，全量程+/-2G，非常精度模式
    I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG1, 0x47); // 使能sensor，设置进入正常模式 ODR 50HZ
    I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG3, 0x10); // 使能INT1新数据中断
    I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG5, 0x08); // 读取数据前INT脚一直拉高
    // 设置FIFO bypass模式
    // I2C_Write_to_LIS2DH12(LIS2DH12_FIFO_CTRL_REG, 0x00); // 0x00: Bypass mode

    // 设置CTRL_REG1寄存器，使能X、Y、Z轴，50Hz采样率
    // I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG1, 0x57); // 0x47: 50Hz, normal mode, all axis enable
    // 设置为高分辨率模式、大端模式、灵敏度2g
    // I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG4, 0x48); // 0x48: 10-bit resolution, Big Endian, +/-2g
    // 读取INT1_SRC寄存器，启动数据转换
    I2C_Read_from_LIS2DH12(LIS2DH12_INT1_SRC);
	/*
    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_X_L);
    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_X_H);

    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Y_L);
    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Y_H);

    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Z_L);
    I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Z_H);*/
    return 0;
}

// 读取LIS2DH12数据
int LIS2DH12_get_value(LIS2DH12_data_t volatile * _LIS2DH12_data)
{
    //uint8_t i = 0;
	LIS2DH12_data_t _LIS2DH12_tmp_data;
    //uint16_t *X_data = value, *Y_data = value + 2, *Z_data = value + 4;
    //uint8_t status;
	// 读取INT1_SRC寄存器，清除INT1脚的高电平
	I2C_Read_from_LIS2DH12(LIS2DH12_INT1_SRC);

    // 读取STATUS_REG寄存器，检查传感器状态。
/*
    status = I2C_Read_from_LIS2DH12(LIS2DH12_STATUS_REG);
    //UartSendStr("LIS2DH12 data:\r\n");
    //UartSendStr("Status:0x");
    //UartSendHex(status);
    // UartSendStr("\r\n");

    // 查看是否有新数据，如果没有就跳过这次读取
    if (!(status & 0x08))
    {
    //    UartSendStr("No new data!\r\n");
        return -1;
    }
*/
    // 读取X、Y、Z轴数据，每个轴2个字节，共6个字节
    /*for (i = 0; i < 6; i++)
    {
        value[i] = I2C_Read_from_LIS2DH12(LIS2DH12_OUT_X_L + i);

     }*/

    _LIS2DH12_tmp_data.x = I2C_Read_from_LIS2DH12(LIS2DH12_OUT_X_L)>>4;
    _LIS2DH12_tmp_data.x += I2C_Read_from_LIS2DH12(LIS2DH12_OUT_X_H)<<4;

    _LIS2DH12_tmp_data.y = I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Y_L)>>4;
    _LIS2DH12_tmp_data.y += I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Y_H)<<4;

    _LIS2DH12_tmp_data.z = I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Z_L)>>4;
    _LIS2DH12_tmp_data.z += I2C_Read_from_LIS2DH12(LIS2DH12_OUT_Z_H)<<4;
    // 将数据转换为角度
/*
    _LIS2DH12_data->x = _LIS2DH12_tmp_data->x/4096.0; // 65520.0 * 360.0;
    _LIS2DH12_data->y = _LIS2DH12_tmp_data->x/4096.0;  // 65520.0 * 360.0;
    _LIS2DH12_data->z = _LIS2DH12_tmp_data->x/4096.0; // 65520.0 * 360.0;*/

    // 将数据转换为16位带符号数
    _LIS2DH12_tmp_data.x = (int16_t)(_LIS2DH12_tmp_data.x << 4) >> 4;
    _LIS2DH12_tmp_data.y = (int16_t)(_LIS2DH12_tmp_data.y << 4) >> 4;
    _LIS2DH12_tmp_data.z = (int16_t)(_LIS2DH12_tmp_data.z << 4) >> 4;

    //此处关闭调度器，避免数据不同步
    //osThreadSuspendAll();
    _LIS2DH12_data->x = _LIS2DH12_tmp_data.x;
    _LIS2DH12_data->y = _LIS2DH12_tmp_data.y;
    _LIS2DH12_data->z = _LIS2DH12_tmp_data.z;
    //osThreadResumeAll();

    return 0;
}


void LIS2DH12_set_power(uint8_t pwr)
{
    if (pwr)
    {
    	//  从掉电模式中恢复时，建议先读取寄存器 REFERENCE (26h) 以彻底复位滤波块。
    	I2C_Read_from_LIS2DH12(LIS2DH12_REFERENCE);
        I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG1, 0x47); // 使能sensor，设置进入正常模式 ODR 50HZ
        I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG3, 0x10); // 使能INT1新数据中断

    }
    else
    {
        I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG1, 0x07); // 关闭sensor，设置进入掉电模式 ODR 25HZ
        I2C_Write_to_LIS2DH12(LIS2DH12_CTRL_REG3, 0x00); // 关闭INT1新数据中断
        I2C_Read_from_LIS2DH12(LIS2DH12_INT1_SRC);
    }
}
