#include "oled.h"
#include "stdlib.h"
#include "oledfont.h"
#include "string.h"
#include "stm32g031xx.h"
#include "usermain.h"

u8 OLED_GRAM[8][144];

extern SPI_HandleTypeDef hspi1;

// extern osSemaphoreId SPI_DMA_SNDNGHandle;

uint8_t OLED_SND_page; // 1-8页
uint8_t ok_to_write_gram_flag = 0;
uint8_t UI_writing = 0;
uint8_t spi_busy = 0;

// 设置亮度：0-3
void OLED_SetBrightness(u8 Brightness)
{
	u8 contrast, VPP, VCOMH;
	switch (Brightness)
	{
	case 0:
		// 挡位0：最暗，对比度:0x00，VPP:0x30，VCOMH:0x25
		contrast = 0x00;
		VPP = 0x30;
		VCOMH = 0x12;
		break;

	case 1:
		// 挡位1：偏暗，对比度:0x00，VPP:0x31，VCOMH:0x30
		contrast = 0x00;
		VPP = 0x31;
		VCOMH = 0x30;
		break;

	case 2:
		// 挡位2：偏亮，对比度:0x7F，VPP:0x32，VCOMH:0x35
		contrast = 0x50;
		VPP = 0x32;
		VCOMH = 0x35;
		break;

	default:
	case 3:
		// 挡位3：最亮，对比度:0xFF，VPP:0x33，VCOMH:0x40
		contrast = 0xFF;
		VPP = 0x33;
		VCOMH = 0x40;
		break;
	}
	OLED_WR_Byte(0x81, OLED_CMD); // 对比度设置
	OLED_WR_Byte(contrast, OLED_CMD);
	OLED_WR_Byte(0x82, OLED_CMD); // VPP电压设置
	OLED_WR_Byte(VPP, OLED_CMD);
	OLED_WR_Byte(0x83, OLED_CMD); // VCOMH电压设置
	OLED_WR_Byte(VCOMH, OLED_CMD);

}

// 反显函数
void OLED_ColorTurn(u8 i)
{
	if (i == 0)
	{
		OLED_WR_Byte(0xA6, OLED_CMD); // 正常显示
	}
	if (i == 1)
	{
		OLED_WR_Byte(0xA7, OLED_CMD); // 反色显示
	}
}

// 屏幕旋转180度
void OLED_DisplayTurn(u8 i)
{
	//const uint8_t turncmd[4] = {0xC8, 0xA1, 0xC0, 0xA0};
	OLED_DC_Clr();
	if (i == 0)
	{
		// HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)turncmd, 2);
		OLED_WR_Byte(0xC8, OLED_CMD); // 正常显示
		OLED_WR_Byte(0xA1, OLED_CMD);
	}
	if (i == 1)
	{
		// HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)turncmd+2, 2);
		OLED_WR_Byte(0xC0, OLED_CMD); // 反转显示
		OLED_WR_Byte(0xA0, OLED_CMD);
	}
	OLED_DC_Set();
}

int OLED_WR_Byte(u8 dat, u8 cmd)
{
	//if(spi_busy) return -1;
	while(spi_busy != 0);
	spi_busy = 1;
	if (cmd)
		OLED_DC_Set();
	else
		OLED_DC_Clr();

	//	if(osMutexWait(SPI_DMA_MutexHandle, 10) == osOK)

	// HAL_SPI_Transmit_DMA(&hspi1, &dat, 1);
	HAL_SPI_Transmit(&hspi1, &dat, 1, 1);
	OLED_DC_Set();
	spi_busy = 0;
	// osSemaphoreRelease(SPI_DMA_SNDNGHandle);
	return 0;
}

// 开启OLED显示
void OLED_DisPlay_On(void)
{
	OLED_WR_Byte(0x8D, OLED_CMD); // 电荷泵使能
	OLED_WR_Byte(0x14, OLED_CMD); // 开启电荷泵
	OLED_WR_Byte(0xAF, OLED_CMD); // 点亮屏幕
}

// 关闭OLED显示
void OLED_DisPlay_Off(void)
{
	OLED_WR_Byte(0x8D, OLED_CMD); // 电荷泵使能
	OLED_WR_Byte(0x10, OLED_CMD); // 关闭电荷泵
	OLED_WR_Byte(0xAE, OLED_CMD); // 关闭屏幕
}

// DMA发送：HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *) arg_ptr, arg_int);
//  注意：必须等待DMA传送完毕
// while(hspi1.TxXferCount);

// 更新显存到OLED
int OLED_Refresh(void)
{
	// uint8_t addr_seq[3] = {0xb0, 0x02, 0x10};
	// if(hspi1.TxXferCount) return -1;
	if(spi_busy) return -1;
	if(UI_writing) return -1;
	
	// addr_seq[0] = 0xb0+i;
	// if(osSemaphoreWait(SPI_DMA_SNDNGHandle, 1000)==osOK)
	//{
	// OLED_DC_Clr();
	// HAL_SPI_Transmit_DMA(&hspi1, addr_seq, 3);
	//}

	// for(n=0;n<128;n++)
	// OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA);
	// if(osMutexWait(SPI_DMA_MutexHandle, 10) == osOK)


	// page增加到超过8时，不会再发送数据，直到page被清零
	if (OLED_SND_page < 8)
	{
		// HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, 1);
		OLED_WR_Byte(0xb0 + OLED_SND_page, OLED_CMD); // 设置行起始地址
		OLED_WR_Byte(0x02, OLED_CMD);	  // 设置低列起始地址
		OLED_WR_Byte(0x10, OLED_CMD);	  // 设置高列起始地址
		OLED_DC_Set();
		spi_busy = 1;
		
		HAL_SPI_Transmit_DMA(&hspi1, &OLED_GRAM[OLED_SND_page][0], 128);
		//OLED_SND_page++;
	}
	else return 1;
	// while(hspi1.TxXferCount);

	return 0;
}

//SPI DMA发送完成中断回调函数
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
	spi_busy = 0;
	OLED_SND_page++;
	if(OLED_SND_page >= 8)
	{
		ok_to_write_gram_flag = 1;
	}
}


// 清屏函数
void OLED_Clear(void)
{
	memset(OLED_GRAM, 0x00, 1152);
	// OLED_Refresh();//更新显示
}

// 画点
// x:0~127
// y:0~63
// t:1 填充, 0 清空, 2 反色
void OLED_DrawPoint(u8 x, u8 y, u8 t)
{
	if (x < 0 || x > 127 || y < 0 || y > 63)
		return;
	u8 i, m, n;
	i = y / 8;
	m = y % 8;
	n = 1 << m;
	if (t==1)		//点亮
	{
		OLED_GRAM[i][x] |= n;
	}
	else if(t==0)	//熄灭
	{
		OLED_GRAM[i][x] &= ~n;
		//OLED_GRAM[i][x] = ~OLED_GRAM[i][x];
		//OLED_GRAM[i][x] |= n;
		//OLED_GRAM[i][x] = ~OLED_GRAM[i][x];
	}
	else if(t==2)	//反色
	{
		OLED_GRAM[i][x] ^= n;
	}
}

// 画线
// x1,y1:起点坐标
// x2,y2:结束坐标
void OLED_DrawLine(int16_t x1, int16_t y1, int16_t x2, int16_t y2, u8 mode)
{
	u16 t;
	int xerr = 0, yerr = 0, delta_x, delta_y, distance;
	int incx, incy, uRow, uCol;
	delta_x = x2 - x1; // 计算坐标增量
	delta_y = y2 - y1;
	uRow = x1; // 画线起点坐标
	uCol = y1;
	if (delta_x > 0)
		incx = 1; // 设置单步方向
	else if (delta_x == 0)
		incx = 0; // 垂直线
	else
	{
		incx = -1;
		delta_x = -delta_x;
	}
	if (delta_y > 0)
		incy = 1;
	else if (delta_y == 0)
		incy = 0; // 水平线
	else
	{
		incy = -1;
		delta_y = -delta_x;
	}
	if (delta_x > delta_y)
		distance = delta_x; // 选取基本增量坐标轴
	else
		distance = delta_y;
	for (t = 0; t < distance + 1; t++)
	{
		OLED_DrawPoint(uRow, uCol, mode); // 画点
		xerr += delta_x;
		yerr += delta_y;
		if (xerr > distance)
		{
			xerr -= distance;
			uRow += incx;
		}
		if (yerr > distance)
		{
			yerr -= distance;
			uCol += incy;
		}
	}
	OLED_DrawPoint(x2, y2, mode);
}

/**
 * @brief 绘制矩形
 * 
 * @param x1 左上角的x坐标
 * @param y1 左上角的y坐标
 * @param x2 右下角的x坐标
 * @param y2 右下角的y坐标
 * @param color 颜色：1-亮，0-暗，2-反色
 * @param fill 是否填充：1-填充，0-不填充
 */
void OLED_DrawRectangle(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint8_t color, uint8_t fill)
{
	if (fill)
	{
		uint16_t x, y;
		for (y = y1; y <= y2; y++)
		{
			for (x = x1; x <= x2; x++)
			{
				OLED_DrawPoint(x, y, color);
			}
		}
	}
	else
	{
		OLED_DrawLine(x1, y1, x2, y1, color);
		OLED_DrawLine(x1, y1, x1, y2, color);
		OLED_DrawLine(x2, y1, x2, y2, color);
		OLED_DrawLine(x1, y2, x2, y2, color);
	}
}
// x,y:圆心坐标
// r:圆的半径
// color:颜色
// fill:是否填满
void OLED_DrawCircle(int16_t x0, int16_t y0, u8 r, u8 color, u8 fill)
{
	int16_t x = 0;
	int16_t y = r;
	int16_t d = 3 - 2 * r;

	while (x <= y)
	{
		if (fill)
		{
			OLED_DrawLine(x0 - x, y0 - y, x0 + x, y0 - y, color); // 上
			OLED_DrawLine(x0 - y, y0 - x, x0 + y, y0 - x, color); // 上
			OLED_DrawLine(x0 - x, y0 + y, x0 + x, y0 + y, color); // 下
			OLED_DrawLine(x0 - y, y0 + x, x0 + y, y0 + x, color); // 下
		}
		else
		{
			OLED_DrawPoint(x0 - x, y0 - y, color); // 左上1
			OLED_DrawPoint(x0 - y, y0 - x, color); // 左上2
			OLED_DrawPoint(x0 + x, y0 - y, color); // 右上1
			OLED_DrawPoint(x0 + y, y0 - x, color); // 右上2
			OLED_DrawPoint(x0 - x, y0 + y, color); // 左下1
			OLED_DrawPoint(x0 - y, y0 + x, color); // 左下2
			OLED_DrawPoint(x0 + x, y0 + y, color); // 右下1
			OLED_DrawPoint(x0 + y, y0 + x, color); // 右下2
		}

		if (d < 0)
		{
			d = d + 4 * x + 6;
		}
		else
		{
			d = d + 4 * (x - y) + 10;
			y--;
		}
		x++;
	}
}

// 在指定位置显示一个字符,包括部分字符
// x:0~127
// y:0~63
// size1:选择字体 6x8/6x12/8x16/12x24
// mode:0,反色显示;1,正常显示
void OLED_ShowChar(u8 x, u8 y, u8 chr, u8 size1, u8 mode)
{
	u8 i, m, temp, size2, chr1;
	u8 x0 = x, y0 = y;
	if (size1 == 8)
		size2 = 6;
	else if(size1 == 16)
		size2 = 16;
	else if(size1 == 32)
		size2 = 64;
	else return;		//不支持的字体大小
	//else
		//size2 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) * (size1 / 2); // 得到字体一个字符对应点阵集所占的字节数

	// 判断整个字符是否在显示区域。字符基准点在左上角
	if (x > 127 || y > 63)
		return; // 右或下越界
	if (x + size1 < 0 || y + size2 < 0)
		return; // 左或上越界

	chr1 = chr - ' '; // 计算偏移后的值
	for (i = 0; i < size2; i++)
	{
		if (size1 == 8)
		{
			temp = asc2_0806[chr1][i];
		} // 调用0806字体
		// else if(size1==12)
		//{temp=asc2_1206[chr1][i];} //调用1206字体
		else if (size1 == 16)
		{
			temp = asc2_1608[chr1][i];
		} // 调用1608字体
		// else if(size1==24)
		//{temp=asc2_2412[chr1][i];} //调用2412字体
		else if(size1==32)
		{
			temp = BigNumsArial[chr - '0'][i];
		}


		else
			return;
		for (m = 0; m < 8; m++)
		{
			if (temp & 0x01)
				OLED_DrawPoint(x, y, mode);
			//else
			//	OLED_DrawPoint(x, y, !mode);
			temp >>= 1;
			y++;
		}
		x++;
		if ((size1 != 8) && ((x - x0) == size1 / 2))
		{
			x = x0;
			y0 = y0 + 8;
		}
		y = y0;
	}
}

// 显示字符串
// x,y:起点坐标
// size1:字体大小
//*chr:字符串起始地址
// mode:0,反色显示;1,正常显示
void OLED_ShowString(u8 x, u8 y, char *chr, u8 size1, u8 mode)
{
	while ((*chr >= ' ') && (*chr <= '~')) // 判断是不是非法字符!
	{
		OLED_ShowChar(x, y, *chr, size1, mode);
		if (size1 == 8)
			x += 6;
		else if(size1 == 16)
			x += 16 / 2;
		chr++;
	}
}


// m^n
u32 OLED_Pow(u8 m, u8 n)
{
	u32 result = 1;
	while (n--)
	{
		result *= m;
	}
	return result;
}

// 显示数字
// x,y :起点坐标
// num :要显示的数字
// len :数字的位数
// size:字体大小
// mode:0,反色显示;1,正常显示
void OLED_ShowNum(u8 x, u8 y, int32_t num, u8 len, u8 size1, u8 mode)
{
	u8 m=0;
	if (size1 == 8)
		m = 1;
	u8 temp, dx=(size1 / 2 + m);
	if (num < 0)
	{
		// neg = 1;
		num = -num;
		if (size1 == 32) OLED_ShowChar(x,y,10+'0',32,mode);
		else OLED_ShowChar(x, y, '-', size1, mode);
	}
	x += dx;
	for (uint8_t t = 0; t < len; t++)
	{
		temp = (num / OLED_Pow(10, len - t - 1)) % 10;
		if (temp == 0)
		{
			OLED_ShowChar(x + dx * t, y, '0', size1, mode);
		}
		else
		{
			OLED_ShowChar(x + dx * t, y, temp + '0', size1, mode);
		}
	}
}

// 显示重量：如果重量是正数，显示3位整数+小数点后2位；如果重量是负数，显示负号+2位整数+小数点后2位。小数点是2x2的点，不在字库中
void OLED_ShowWeight(u8 x, u8 y, double num, u8 mode)
{
	u8 temp;
	// 范围限制：-99.99 ~ 999.99
	if (num > 999.99)
	{
		num = 999.99;
	}
	else if (num < -99.99)
	{
		num = -99.99;
	}
	// 数据处理
	if (num < 0)
	{
		OLED_ShowChar(x, y, 10+'0', 32, 1);
		num = -num;
	}
	// 获取小数部分。需要四舍五入
	//uint8_t decimal = (uint8_t)((num - (int)(num)) * 100);
	uint8_t decimal = (uint8_t)((num - (int)(num)) * 100 + 0.5);
	// 如果小数部分大于等于100，进位
	if(decimal >= 100)
	{
		decimal = 0;
		num += 1;
	}
	
	// 显示整数部分，前面的0不显示
	if ((int)num >= 100)
	{
		temp = (int)num / 100;
		OLED_ShowChar(x, y, temp + '0', 32, mode);
	}
	if ((int)num >= 10)
	{
		temp = (int)num / 10 % 10;
		OLED_ShowChar(x + 16, y, temp + '0', 32, mode);
	}
	temp = (int)num % 10;
	OLED_ShowChar(x + 32, y, temp + '0', 32, mode);

	// 显示小数点（四个像素点）
	OLED_DrawPoint(x + 49, 25+y, mode);
	OLED_DrawPoint(x + 49, 25+y + 1, mode);
	OLED_DrawPoint(x + 50, 25+y, mode);
	OLED_DrawPoint(x + 50, 25+y + 1, mode);

	// 显示小数部分
	temp = decimal / 10;
	OLED_ShowChar(x + 51, y, temp + '0', 32, mode);
	temp = decimal % 10;
	OLED_ShowChar(x + 51+16, y, temp + '0', 32, mode);

	// 显示单位
	OLED_ShowChar(x + 51+32, y+12, 'g', 16, mode);
}

//显示汉字
//x,y:起点坐标
//num:汉字对应的序号
//mode:0,反色显示;1,正常显示
void OLED_ShowChinese(u8 x,u8 y,u8 num,u8 mode)
{
	u8 m,temp;
	u8 x0=x,y0=y;
	u16 i=0,size3;//=(size1/8+((size1%8)?1:0))*size1;  //得到字体一个字符对应点阵集所占的字节数
	size3 = 28;			//字体一个字符对应点阵集所占的字节数
	for(i=0;i<size3;i++)
	{
		temp=Hzk1[num][i];//调用16*16字体(只有这个了)
		for(m=0;m<8;m++)
		{
			if(temp&0x01)OLED_DrawPoint(x,y,mode);
			//else OLED_DrawPoint(x,y,!mode);
			temp>>=1;
			y++;
		}
		x++;
		if((x-x0)==14)
		{x=x0;y0=y0+8;}
		y=y0;
	}
}

// num 显示汉字的个数
// space 每一遍显示的间隔
// mode:0,反色显示;1,正常显示
void OLED_ScrollDisplay(u8 num, u8 space, u8 mode)
{
	u8 i, n, t = 0, m = 0, r;
	while (1)
	{
		if (m == 0)
		{
			OLED_ShowChinese(128, 24, t, mode); // 写入一个汉字保存在OLED_GRAM[][]数组中
			t++;
		}
		if (t == num)
		{
			for (r = 0; r < 16 * space; r++) // 显示间隔
			{
				for (i = 1; i < 144; i++)
				{
					for (n = 0; n < 8; n++)
					{
						OLED_GRAM[n][i - 1] = OLED_GRAM[n][i];
					}
				}
				OLED_Refresh();
			}
			t = 0;
		}
		m++;
		if (m == 16)
		{
			m = 0;
		}
		for (i = 1; i < 144; i++) // 实现左移
		{
			for (n = 0; n < 8; n++)
			{
				OLED_GRAM[n][i - 1] = OLED_GRAM[n][i];
			}
		}
		OLED_Refresh();
	}
}

//显示汉字串
void OLED_ShowChinese_String(u8 x,u8 y,const unsigned char str[],u8 length, u8 mode)
{
	int t;
	for(t=0;t<length;t++)
	{
		OLED_ShowChinese(x+t*14, y, str[t], mode);
	}
}

// x,y：起点坐标
// sizex,sizey,图片长宽
// BMP[]：要写入的图片数组
// mode:0,反色显示;1,正常显示
void OLED_ShowPicture(u8 x, u8 y, u8 sizex, u8 sizey, u8 BMP[], u8 mode)
{
	u16 j = 0;
	u8 i, n, temp, m;
	u8 x0 = x, y0 = y;
	sizey = sizey / 8 + ((sizey % 8) ? 1 : 0);
	for (n = 0; n < sizey; n++)
	{
		for (i = 0; i < sizex; i++)
		{
			temp = BMP[j];
			j++;
			for (m = 0; m < 8; m++)
			{
				if (temp & 0x01)
					OLED_DrawPoint(x, y, mode);
				else
					OLED_DrawPoint(x, y, !mode);
				temp >>= 1;
				y++;
			}
			x++;
			if ((x - x0) == sizex)
			{
				x = x0;
				y0 = y0 + 8;
			}
			y = y0;
		}
	}
}
// OLED的初始化
// extern DMA_HandleTypeDef hdma_spi1_tx;
// void DMA_Transfer_Complete_Callback();
void OLED_Init(void)
{
	// 注册DMA传输完毕回调函数
	// HAL_DMA_RegisterCallback(&hdma_spi1_tx, HAL_DMA_XFER_CPLT_CB_ID, DMA_Transfer_Complete_Callback);
	OLED_RES_Clr();
	//osDelay(200);
	HAL_Delay(50);
	OLED_RES_Set();
	HAL_Delay(100);

	OLED_WR_Byte(0xAE, OLED_CMD); /*display off*/
	OLED_WR_Byte(0x02, OLED_CMD); /*set lower column address*/
	OLED_WR_Byte(0x10, OLED_CMD); /*set higher column address*/
	OLED_WR_Byte(0x40, OLED_CMD); /*set display start line*/
	OLED_WR_Byte(0xB0, OLED_CMD); /*set page address*/

	//OLED_WR_Byte(0x81, OLED_CMD); /*对比度*/
	//OLED_WR_Byte(0xff, OLED_CMD); /*0x00-0xFF*/							//影响亮度：越高越亮

	OLED_WR_Byte(0xA1, OLED_CMD); /*set segment remap*/
	OLED_WR_Byte(0xA6, OLED_CMD); /*normal / reverse*/
	OLED_WR_Byte(0xA8, OLED_CMD); /*multiplex ratio*/
	OLED_WR_Byte(0x3F, OLED_CMD); /*duty = 1/64*/
	OLED_WR_Byte(0xad, OLED_CMD); /*set charge pump enable*/
	OLED_WR_Byte(0x8b, OLED_CMD); /* 0x8B 内供 VCC */

	//OLED_WR_Byte(0x33, OLED_CMD); /*0X30---0X33 set VPP 电荷泵电压 */		//影响亮度：越高越亮

	OLED_WR_Byte(0xC8, OLED_CMD); /*Com scan direction*/
	OLED_WR_Byte(0xD3, OLED_CMD); /*set display offset*/
	OLED_WR_Byte(0x00, OLED_CMD); /* 0x20 */
	OLED_WR_Byte(0xD5, OLED_CMD); /*set osc division*/
	OLED_WR_Byte(0x80, OLED_CMD);

	OLED_WR_Byte(0xD9, OLED_CMD); /*set pre-charge period*/
	OLED_WR_Byte(0x18, OLED_CMD); /*0x_0 - 0x_f，默认是0x22*/							//变化不明显

	OLED_WR_Byte(0xDA, OLED_CMD); /*set COM pins*/
	OLED_WR_Byte(0x12, OLED_CMD);

	//OLED_WR_Byte(0xdb, OLED_CMD); /*set vcomh*/
	//OLED_WR_Byte(0x35, OLED_CMD); /*0x00 - 0x40，默认0x35*/						//影响亮度：越高越亮

	//设置亮度
	OLED_SetBrightness(device_setting.scrn_brightness);

	OLED_Clear();
	//OLED_Refresh();
	//OLED_WR_Byte(0xAF, OLED_CMD); /*display ON*/
}
