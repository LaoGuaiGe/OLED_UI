/*
 * scale.c
 *
 *  Created on: Nov 22, 2024
 *      Author: tonny
 */
#include "ADS1231.h"
#include "main.h"
#include "string.h"
#include "LIS2DH12.h"
#include "stdlib.h"
#include "math.h"
#include "scale.h"
#include "usermain.h"

int32_t volatile raw_scale_data[ADS1231_DATA_RATE_SPS];

//sys_cali_data_t sys_cali_data;

int32_t volatile scaleDataNow = 0;
int32_t volatile scaleFilteredDataNow = 0;

double weight; // 计算后的最终重量，克

// 中位值滤波用的比较函数，输入：两个double，输出：int
int compare(const void *a, const void *b)
{
	// 比较浮点数的大小。不转换为整数
	if (*(double *)a > *(double *)b)
	{
		return 1;
	}
	else if (*(double *)a < *(double *)b)
	{
		return -1;
	}
	else
	{
		return 0;
	}
}

void ScaleTask()
{

	// 等待新数据
	if (HAL_GPIO_ReadPin(ADS1231_DOUT_GPIO_Port, ADS1231_DOUT_Pin)) // AD转换未结束则等待，否则开始读取
	{
		return;
	}
	// 读取数据
	scaleDataNow = ReadADS1231();

	// 进行数据移位
	// osMutexWait(ReadScaleMutexHandle, 100);
	for (int i = ADS1231_DATA_RATE_SPS - 1; i > 0; i--)
	{
		raw_scale_data[i] = raw_scale_data[i - 1];
	}
	// 写入新数据
	raw_scale_data[0] = scaleDataNow;
	// osMutexRelease(ReadScaleMutexHandle);
	/*
	//中位值滤波
	//复制数据。只需要复制SCALE_DATA_FAST_REFRESH_TIME_MS时间段内的数据
	//时间段内的数据个数：SCALE_DATA_FAST_REFRESH_TIME_MS/1000*ADS1231_DATA_RATE_SPS
	#define DATA_NUM (SCALE_DATA_FAST_REFRESH_TIME_MS/1000*ADS1231_DATA_RATE_SPS)
	int32_t tmp_data[DATA_NUM];
	for(int i=0;i<DATA_NUM;i++)
	{
		tmp_data[i] = raw_scale_data[i];
	}
	//排序
	qsort(tmp_data, DATA_NUM, sizeof(int32_t), compare(a,b));
	//取中位值
	scaleFilteredDataNow = tmp_data[DATA_NUM/2];

	*/
}

int32_t volatile scale_filtered_data;
extern LIS2DH12_data_t volatile LIS2DH12_data;
void scale_timer_callback(void *argv, unsigned short int argc)
{
	//const double pi_div_2 = 1.5707963267948966192313216916398;
	int32_t scale_data[ADS1231_DATA_RATE_SPS];
	// uint8_t isStable = 0;

	int32_t volatile scale_tmp_data = 0;

	// osDelay(SCALE_DATA_SLOW_REFRESH_TIME_MS);
	//  读取重量传感器数据
	// osMutexWait(ReadScaleMutexHandle, 100);
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_data[i] = raw_scale_data[i];
	}
	// osMutexRelease(ReadScaleMutexHandle);

	// ADS1231取平均
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_tmp_data += (scale_data[i] / ADS1231_DATA_RATE_SPS);
	}

	// 输出
	scale_filtered_data = scale_tmp_data;
	scale_tmp_data = 0;

	// 倾角计算。
	// double alpha = (((LIS2DH12_raw_data.x ^ 0x800) - 2048) / 1024.0) - sys_cali_data.x_offset;
	//double beta = ((double)LIS2DH12_data.y / 1024.0 * pi_div_2) - sys_cali_data.y_offset;
	//double gamma = ((double)LIS2DH12_data.z / 1024.0 * pi_div_2) - sys_cali_data.z_offset;

	// double volatile cb = cos(beta);
	// double volatile cg = cos(gamma);

	// 计算补偿后的重量值
	// 重量值与x方向平行。
	//sys_cali_data.multiplier = -0.0005;
	// 未调平的重量值
	double calid_scale_data = (scale_filtered_data - device_setting.sys_cali_data.zero_value) * device_setting.sys_cali_data.multiplier;
	// debug
	// calid_scale_data = (double)scale_filtered_data;
	// 根据校准数据计算调平后重量值
	//weight = (double)calid_scale_data / cos(beta) / cos(gamma);
	// 不进行倾斜补偿。
	weight = calid_scale_data;
}

void scale_get_zero_value()
{
	// 计算电子秤的零点值
	int32_t scale_data[ADS1231_DATA_RATE_SPS];
	int32_t scale_tmp_data = 0;

	// 读取重量传感器数据
	// osMutexWait(ReadScaleMutexHandle, 100);
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_data[i] = raw_scale_data[i];
	}
	// osMutexRelease(ReadScaleMutexHandle);

	// ADS1231取平均
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_tmp_data += (scale_data[i] / ADS1231_DATA_RATE_SPS);
	}

	// 输出
	device_setting.sys_cali_data.zero_value = scale_tmp_data;

	// TODO: 保存校准数据
}

// 砝码重量表
// uint32_t weight_table[] = {10, 20, 50, 100, 200, 500};
/**
 * @brief 电子秤校准（乘数）
 *
 * @param  砝码重量
 */
void scale_calibrate(uint32_t cali_weight)
{
	int32_t scale_data[ADS1231_DATA_RATE_SPS];
	int32_t scale_tmp_data = 0;
	// 读取重量传感器数据
	// osMutexWait(ReadScaleMutexHandle, 100);
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_data[i] = raw_scale_data[i];
	}
	// osMutexRelease(ReadScaleMutexHandle);

	// ADS1231取平均
	for (int i = 0; i < ADS1231_DATA_RATE_SPS; i++)
	{
		scale_tmp_data += (int)((double)scale_data[i] / (double)ADS1231_DATA_RATE_SPS + 0.5);
	}

	// 读取姿态传感器数据
	// double alpha = (((LIS2DH12_raw_data.x ^ 0x800) - 2048) / 1024.0) - sys_cali_data.x_offset;
	//double beta = (((LIS2DH12_data.y ^ 0x800) - 2048) / 1024.0) - sys_cali_data.y_offset;
	//double gamma = (((LIS2DH12_data.z ^ 0x800) - 2048) / 1024.0) - sys_cali_data.z_offset;

	// 计算补偿后的重量值
	//double calid_scale_data = (double)scale_filtered_data / cos(beta) / cos(gamma);


	// 计算乘数
	device_setting.sys_cali_data.multiplier = (double)cali_weight / (double)(scale_tmp_data - device_setting.sys_cali_data.zero_value);

	//sys_cali_data.is_calibrated = 1;
}

void scale_init()
{
	device_setting.sys_cali_data.multiplier = 0.0005;
}
